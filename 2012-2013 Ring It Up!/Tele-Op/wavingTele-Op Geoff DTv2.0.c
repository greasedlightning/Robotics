#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  HTMotor)
#pragma config(Motor,  mtr_S1_C1_2,     motorFL,       tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_1,     motorBL,       tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C4_2,     motorFR,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     motorBR,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     armR,          tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     ramp,          tmotorTetrix, openLoop, encoder, reversed)
#pragma config(Servo,  srvo_S1_C3_1,    servo1,               tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    servo2,               tServoStandard)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoStandard)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoStandard)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoStandard)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoStandard)
#pragma config(Sensor, S2,     LEGOLS,              sensorI2CCustom)
#pragma config(Sensor, S3,     light,              sensorI2CCustom)
#pragma config(Sensor, S4,     HTSMUX,              sensorI2CCustom)
//#pragma config(Sensor, S2,     lightSensor,            sensorLightActive)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"
#include "/hitechnic-sensormux.h"
#include "/lego-ultrasound.h"
#include "/lego-light.h"
#include "/hitechnic-force.h"
// The sensor is connected to the first port
// of the SMUX which is connected to the NXT port S1.
// To access that sensor, we must use msensor_S1_1.  If the sensor
// were connected to 3rd port of the SMUX connected to the NXT port S4,
// we would use msensor_S4_3

// Give the sensor a nice easy to use name
const tMUXSensor HTFS1 = msensor_S4_2;
const tMUXSensor HTFS2 = msensor_S4_3;
const tMUXSensor IRSENSOR = msensor_S4_1;
const tMUXSensor LEGOTS = msensor_S4_4;
const int threshold = 35; //Controller Input Threshold

float mult,mult2;
bool toggle,toggle2,rampLock,up=false;
int fs1,fs2;
int dist,ser=0,time=0,lsVal=0,armEncoder=0;

int map(int val,int fRange, int lRange, int swag){
	return swag*(val/lRange-fRange);
}

void init(){
	fs1 = fs2 = dist = 0; //Force Sensor Values
	mult = mult2 = 1; //Speed Control
	rampLock=toggle = toggle2 = true; //Speed Toggles
	nMotorEncoder[ramp] = 0; //Initiate Encoder Pos
	nMotorEncoder[armR] = 0; //Initiate Encoder Pos
	bFloatDuringInactiveMotorPWM = false;
	servoChangeRate[servo1] = 10;
	servoChangeRate[servo2] = 10;
  LSsetActive(LEGOLS);
  lsVal = LSvalRaw(LEGOLS);
  ser=0;
}

task main()
{
	init();

	waitForStart(); //Waits for FTC match to officialy start

	//Main Loop
	while(true){
	  getJoystickSettings(joystick);
	  armEncoder=nMotorEncoder[armR];
		lsVal = LSvalRaw(LEGOLS);
		if(ServoValue[servo1]==100&&up&&ServoValue[servo2]==215-ser){
			ser=0;
 		 	up=false;
		}
		if(ServoValue[servo1]==0&&ServoValue[servo2]==215-ser&&!up){
			ser=100;
			up=true;
		}
		servo[servo1]=ser;
 	 servo[servo2]=215-ser;
	  //Update Motors////////////


	  ///////////////////////////


	  //Update Servos////////////
  	if(rampLock){
  		servo[servo3]=35;
  	}
  	else{
  		servo[servo3]=100;
  	}
	  ///////////////////////////
  	//Hi Alejandro :D
	  //Update Sensors///////////
	  //Check for weighted Ring///
	  fs1 = HTFreadSensor(HTFS1);
	  fs2 = HTFreadSensor(HTFS2);
	  if(fs1<1024)
	  	fs1+=1000;
	  if(fs2<1024)
	  	fs2+=1000;

		if(fs1>1410||fs2>1375){//||(fs2>1325&&fs1<1160&&fs1>1150)){
	  	LSsetActive(light);
	  	//motor[light]=100;
	  	//PlaySound(soundBlip);
		}
		else{
			LSsetInactive(light);
			//motor[light]=0;
		}
    nxtDisplayCenteredTextLine(1,"Servo:%i %i",servo[servo1],ser);
		nxtDisplayCenteredTextLine(2,"Force1: %i",fs1);
		nxtDisplayCenteredTextLine(3,"Force2: %i",fs2);
		nxtDisplayCenteredTextLine(4,"RawColor: %i",lsVal);
		nxtDisplayCenteredTextLine(5,"Encoder: %i",armEncoder);
		////////////////////////////

		//Gamepad 2(Arm and claw Control)////////////////

	  getJoystickSettings(joystick);
		if(joy2Btn(1)){ //Speed Toggle
	    while(joy2Btn(1)){}
	    toggle2 = !toggle2;
	  }
	  if(toggle2)
	    mult2 = 1;
	  if(!toggle2) //USE AN ELSE STATMENT!!!
	    mult2 = .5;


	  getJoystickSettings(joystick);
	  if(joy2Btn(5)){ //Arm Control
	    motor[armR] = 100*.5*mult2;//mult2;
	    //motor[armL] = 100*mult2;
	  }
	  else if(joy2Btn(6)){
	    motor[armR] = -100*mult2;
	    //motor[armL] = -100*mult2;
	  }
	  else{
	    motor[armR] = 0;
	    //motor[armL] = 0;
	  }
	 	//////////////////////////////

	  //Gamepad 1(Drive Train Control)///////////////////
	  getJoystickSettings(joystick);
	  if(joy1Btn(1)){ //Speed Toggledjjj
	    while(joy1Btn(1)){}
	    toggle = !toggle;
	  }
	  if(joy1Btn(6)){
	  	motor[ramp]=-50;
	  }
	  else if(joy1Btn(5)){
	  	motor[ramp]=100;
	  }
	  else{
	  	motor[ramp]=0;//UNESSECARRY BRACKETS
	  }

	  if(joy1Btn(4)){
	  	while(joy1Btn(4)){}
	  	rampLock=!rampLock;
		}
	  if(toggle)
	     mult=.8;
	  if(!toggle||abs(armEncoder)>150)
	     mult=.5;

	  getJoystickSettings(joystick);
	  if(abs(joystick.joy1_y1)>threshold){ //Diagonal Forward Right & Backwards Left
	  	motor[motorFL] = joystick.joy1_y1*mult;
	  	motor[motorBL] = joystick.joy1_y1*mult;
		}
		else{
	  	 motor[motorBL] = 0;
	  	 motor[motorFL] = 0;
	  }
		if(abs(joystick.joy1_y2)>threshold){
			motor[motorFR] = joystick.joy1_y2*mult;
			motor[motorBR] = joystick.joy1_y2*mult;
		}
		else{ //Stop Motors
			 motor[motorFR] = 0;
	  	 motor[motorBR] = 0;
	  }
	  ////////////////////////////////////////////
    time+=10;
    wait1Msec(10);
  }
}
