#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Motor,  mtr_S1_C1_1,     motorFL,       tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     motorBL,       tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_1,     motorFR,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     motorBR,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     armR,          tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     ramp,          tmotorTetrix, openLoop, encoder, reversed)
#pragma config(Servo,  srvo_S1_C4_1,    servo1,               tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    servo2,               tServoStandard)
#pragma config(Servo,  srvo_S1_C4_3,    servo3,               tServoStandard)
#pragma config(Servo,  srvo_S1_C4_4,    servo4,               tServoStandard)
#pragma config(Servo,  srvo_S1_C4_5,    servo5,               tServoStandard)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoStandard)
#pragma config(Sensor, S2,     LEGOLS,              sensorI2CCustom)
#pragma config(Sensor, S3,     light,              sensorI2CCustom)
#pragma config(Sensor, S4,     HTSMUX,              sensorI2CCustom)
//#pragma config(Sensor, S2,     lightSensor,            sensorLightActive)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"
#include "/hitechnic-sensormux.h"
#include "/lego-ultrasound.h"
#include "/lego-light.h"
#include "/hitechnic-force.h"
// The sensor is connected to the first port
// of the SMUX which is connected to the NXT port S1.
// To access that sensor, we must use msensor_S1_1.  If the sensor
// were connected to 3rd port of the SMUX connected to the NXT port S4,
// we would use msensor_S4_3

// Give the sensor a nice easy to use name
const tMUXSensor HTFS1 = msensor_S4_2;
const tMUXSensor HTFS2 = msensor_S4_3;
const tMUXSensor IRSENSOR = msensor_S4_1;
const tMUXSensor LEGOTS = msensor_S4_4;
const int threshold = 35; //Controller Input Threshold

float mult,mult2;
bool toggle,toggle2,rampLock;
int fs1,fs2;
int dist,ser=0,lsVal=0,armEncoder=0;

int map(int val,int fRange, int lRange, int swag){
	return swag*(val/lRange-fRange);
}

void init(){
	fs1 = fs2 = dist = 0; //Force Sensor Values
	mult = mult2 = 1; //Speed Control
	rampLock=toggle = toggle2 = true; //Speed Toggles
	nMotorEncoder[ramp] = 0; //Initiate Encoder Pos
	nMotorEncoder[armR] = 0; //Initiate Encoder Pos
	bFloatDuringInactiveMotorPWM = false;
	servoChangeRate[servo1] = 10;
	servoChangeRate[servo2] = 10;
  LSsetActive(LEGOLS);
  lsVal = LSvalRaw(LEGOLS);
}


task joystick1(){
	while(true){
	 //Gamepad 1(Drive Train Control)///////////////////
	  getJoystickSettings(joystick);
	  if(joy1Btn(1)){ //Speed Toggledjjj
	    while(joy1Btn(1)){}
	    toggle = !toggle;
	  }
	  if(joy1Btn(6)){
	  	motor[ramp]=-50;
	  }
	  else if(joy1Btn(5)){
	  	motor[ramp]=100;
	  }
	  else{
	  	motor[ramp]=0;///////////////////UNESSECARRY BRACKETS
	  }

	  if(joy1Btn(4)){
	  	while(joy1Btn(4)){}
	  	rampLock=!rampLock;
		}
	  if(toggle)
	     mult=.8;
	  if(!toggle||abs(armEncoder)>150)
	     mult=.5;

	  getJoystickSettings(joystick);
	  if(abs(joystick.joy1_y1)>threshold){ //Diagonal Forward Right & Backwards Left
	  	motor[motorFL] = joystick.joy1_y1*mult;
	  	motor[motorBL] = joystick.joy1_y1*mult;
		}
		else{
	  	 motor[motorBL] = 0;
	  	 motor[motorFL] = 0;
	  }
		if(abs(joystick.joy1_y2)>threshold){
			motor[motorFR] = joystick.joy1_y2*mult;
			motor[motorBR] = joystick.joy1_y2*mult;
		}
		else{ //Stop Motors
			 motor[motorFR] = 0;
	  	 motor[motorBR] = 0;
	  }
	  ////////////////////////////////////////////
	}
}

task joystick2(){
	while(true){
	//Gamepad 2(Arm and claw Control)////////////////

	  getJoystickSettings(joystick);
		if(joy2Btn(1)){ //Speed Toggle
	    while(joy2Btn(1)){}
	    toggle2 = !toggle2;
	  }
	  if(toggle2)
	    mult2 = 1;
	  if(!toggle2)////////////////////////////USE AN ELSE STATMENT!!!
	    mult2 = .5;

	  getJoystickSettings(joystick);
			if(joy2Btn(7))
				ser++;
			else if(joy2Btn(8))
				ser--;
		if(joy2Btn(3))
			ser=100;
		else if(joy2Btn(4))
			ser=0;
	  if(ser>255)
	  	ser=255;
	 	else if(ser<0)
	 		ser=0;

	  getJoystickSettings(joystick);
	  if(joy2Btn(5)){ //Arm Control
	    motor[armR] = 100*.5*mult2;//mult2;
	    //motor[armL] = 100*mult2;
	  }
	  else if(joy2Btn(6)){
	    motor[armR] = -100*mult2;
	    //motor[armL] = -100*mult2;
	  }
	  else{
	    motor[armR] = 0;
	    //motor[armL] = 0;
	  }
	 	//////////////////////////////
	}
}

task updateServos(){
	while(true){
	  //Update Servos////////////
		servo[servo1]=ser;
  	servo[servo2]=215-ser;
  	if(rampLock){
  		servo[servo3]=35;
  	}
  	else{
  		servo[servo3]=100;
  	}
	  ///////////////////////////
  }
}

task checkForWeighted(){
	while(true){
	  fs1 = HTFreadSensor(HTFS1);
	  fs2 = HTFreadSensor(HTFS2);
	  if(fs1<1024)
	  	fs1+=1000;
	  if(fs2<1024)
	  	fs2+=1000;

		if(fs1>1410||fs2>1375){
	  	LSsetActive(light);
		}
		else{
			LSsetInactive(light);
		}
	}
}

task updateSensors(){
	while(true){
	  armEncoder=nMotorEncoder[armR];
		lsVal = LSvalRaw(LEGOLS);
	}
}


task main()
{
	init();

	waitForStart(); //Waits for FTC match to officialy start

	//Main Loop
	//while(true){
		hogCPU();
	  getJoystickSettings(joystick);

	  StartTask(updateSensors);

		StartTask(updateServos);

  	//Hi Alejandro :D
	  //Update Sensors///////////
	  //Check for weighted Ring///
		StartTask(checkForWeighted);

	  getJoystickSettings(joystick);
		StartTask(joystick1);

	  getJoystickSettings(joystick);
		StartTask(joystick2);
		releaseCPU();

		///////Sensor Debugging/////
    nxtDisplayCenteredTextLine(1,"Servo:%i %i",servo[servo1],ser);
		nxtDisplayCenteredTextLine(2,"Force1: %i",fs1);
		nxtDisplayCenteredTextLine(3,"Force2: %i",fs2);
		nxtDisplayCenteredTextLine(4,"RawColor: %i",lsVal);
		nxtDisplayCenteredTextLine(5,"Encoder: %i",armEncoder);
		////////////////////////////

}
